# 3장 자바와 객체 지향

- 클래스 : 분류에 대한 "개념"

- 객체 : 세상에 존재하는 유일무이한 사물

  - 클래스는 "분류"의 이름으로, 객체는 "유일무이한 사물"의 이름으로 작명해야 함

    ex) 조류 bird = new 조류();   < 인스턴스명을 잘 못 작성한 예시 >

    1. 조류의 나이는? 조류의 크기는? --> 조류는 "분류"의 개념이기 떄문에 해당질의에 답을 할 수 없으므로 클래스이다.
    2. bird의 나이는? bird의 크기는? --> 같은 이유로 답을 할 수 없으므로 "분류"", 클래스이다.

    ex) 펭귄 뽀로로 = new 펭귄(); < 인스턴스명을 잘 작성한 예시 >

    1. 펭귄의 나이는? 펭귄의 크기는? --> 펭귄은 "분류"의 개념이기 떄문에 해당질의에 답을 할 수 없으므로 클래스이다.
    2. 뽀로로의 나이는? 뽀로로의 크기는? --> 뽀로로라는 유일무이한 사물의 특징이므로, 대답이 가능함



---



- 객체지향의 4대 특성

  - **캡슐화 : 접근 제어자 priate, [default], protected, public을 통한 접근 제한**

    1. private : 본인만 접근가능

    2. [default] : 같은 패키지 내의 클래스에서 접근 가능

    3. protected : 상속/같은 패키지내의 클래스에서 접근 가능

    4. public : 모두가 접근 가능

    5. 상속을 받지 않았다면 객체 맴버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.

    6. 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장함

       ex) 권장 클래스명.정적멤버) 사람.인구 

       ex) 비권장 객체명.정적멤버) 이원기.인구

  - **상속 : 부모 - 자식 관계보다는, 동물 - 포유류와 같은 구체화, 분류도와 같이 부모의 "확장"의 개념**

    1. 상속은 상위 클래스의 특성을 "재사용"하는 것

    2. 상속은 상위 클래스의 특성을 "확장"하는 것

    3. 상속은 is a kind of의 관계를 만족해야 함

       * 하위 클래스는  상위 클래스다. ( ex) 포유류는 동물이다. )
       * 자바는 어째서 다중 상속을 지원하지 않는가? : 두개 이상의 상위 클래스를 상속받은 하위 클래스의 특징 중 상위 클래스의 공통 행위(메소드)가 존재할 떄 하위 클래스는 어떠한 것을 따라야 하는가? 하는 논리적 문제가 발생. 다중 상속으로 인한 득보다 실이 크다고 판단하여 Java에서는 다중상속을 지원하지 않는다. 

    4. 인터페이스 란?

       * Java는 다중상속을 지원하지 않지만, 인터페이스를 이용하여 다중상속의 효과를 볼 수 있음
       * 구현 클래스 is able to 인터페이스의 개념 ( 구현 클래스는 인터페이스 "할 수 있다." )
       * 인터페이스는 구현 클래스의 할 수 있는 것의 이름을 "정의"한 것이므로, 작명을 "~할 수 있는"으로 작명하는 것이 좋음

    5. 상속과 T 메모리

       * <span style="color:blue">하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.</span>

         ex) Penguin pororo = new Penguin();

         ex) Animal pingu = new Penguin();

       ![상속T메모리](https://user-images.githubusercontent.com/48685242/107844636-779d4c80-6e18-11eb-9496-c655b79b4c20.jpg)

  - **추상화 : 구체적인 것을 분해해서 관심 영역(어플리케이션 경계)에 있는 특성만 가지고 재조합 하는 것**

    1. 구체적인 Class에는 굉장히 많은 특징과, 행위가 존재하지만, 내가 만들고자하는 영역에서 보면 특징, 행위가 매우 제한적으로 설계가능함

    2. 사용하고자 하는 특징, 행위를 추출하는 것을 "모델링"이라고 함

       ex) 사람이라는 구체적 Class는 시력/몸무게/혈액형/키/나이/직업/먹는행위/일하는행위/운동하는행위 등 매우 많은 특징과 행위를 가지지만, 내가 만들고자하는 "은행"어플리케이션에서의 사람은 "고객"으로 한정되며, 나이/직업/일하는행위정도로만 특징과 행위를 추출할 수 있다.

    3. 추상화와 T메모리

       ex) Mouse는 이름/나이/신장/체중/종/꼬리갯수/먹는행위/자는행위/무는행위/달리는행위 등 많은 특징/행위를 가지지만 내가 구현할려는 목적의 특징은 이름/나이/꼬리갯수/노래부르는행위 만 필요하면 아래와같이 정의할 수 있음

       ![추상화T메모리](https://user-images.githubusercontent.com/48685242/107845252-7d496100-6e1d-11eb-80de-8a7851595944.jpg)

  - **다형성 : 오버라이딩 / 오버로딩**

    1. 오버라이딩(OverRiding) : 같은 메소드 이름/같은 인자 목록/상위 클래스의 메소드 "재정의"

    2. 오버로딩(OverLoading) : 같은 메소드 이름/다른 인자목록/다수의 메소드를 "중복 정의"

    3. 다형성과 T메모리

       ex) Penguin pororo = new Penguin();

       ex) Animal pingu = new Penguin();

       ![다형성T메모리](https://user-images.githubusercontent.com/48685242/107844821-27bf8500-6e1a-11eb-833c-9d309677a994.jpg)



---



- 혼용하여 사용하는 개념
  - 클래스 맴버 = 정적 맴버 = 스태틱 멤버
  - 객체 멤버 = 오브젝트 멤버 = 인스턴스 멤버
  - 필드 = 속성 = 프로퍼티
  - 함수 = 메서드
  - 변수 공간 = 메모리 공간
